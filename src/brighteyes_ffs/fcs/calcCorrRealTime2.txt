t = np.arange(0,10000,1)
y = np.sin(2*np.pi*0.01*t) + 1 + 0.02*np.random.rand((10000))

maxx=20
delays=np.round(2**np.arange(0,maxx))
delays = np.unique(delays)
maxx = len(delays)

intensityBin = np.zeros((maxx, 2))
partialcorrelation = np.zeros((maxx, 1))
corrout = np.zeros((maxx, 1))

plt.figure()
plt.plot(t, y)

NphotTot = 0

for c in range(len(y)):
    # check which bin (0 or 1)
    col = (np.mod(c, 2*delays) >= delays).astype(int)
    # add photons to bin
    for b in range(maxx):
        intensityBin[b, col[b]] += y[c]
    # check if bin is full
    binfull = np.mod(c, delays) == delays - 1
    for b in range(maxx):
        if binfull[b]:
            partialcorrelation[b] += intensityBin[b, 0] * intensityBin[b, 1]
            intensityBin[b,1-col[b]] = 0
    # calculate total detected photons
    NphotTot += y[c]
    # normalize correlation
    corrout *= 0
    for b in range(maxx):
        if -1 * np.sum(intensityBin[b,:]) + NphotTot > 0:
            corrout[b] = partialcorrelation[b] / (-1 * np.sum(intensityBin[b,:]) + NphotTot)**2 * (np.floor(c / delays[b]) - 1) - 1

plt.figure()
plt.plot(delays, corrout)
plt.xscale('log')

intensityBin = np.zeros((maxx, 4))
partialcorrelation = np.zeros((maxx, 1))
corrout = np.zeros((maxx, 1))

NphotTot = 0

for c in range(len(y)):
    # check which bin (0, 1, 2, 3)
    col = np.floor(np.mod(c, 4*delays) / delays).astype(int)
    # add photons to bin
    for b in range(maxx):
        intensityBin[b, col[b]] += y[c]
    # check if bin is full
    binfull = np.mod(c, delays) == delays - 1
    for b in range(maxx):
        if binfull[b]:
            partialcorrelation[b] += intensityBin[b, col[b]] * intensityBin[b, np.mod(col[b]+2, 4)]
            intensityBin[b, np.mod(col[b]+2, 4)] = 0
    # calculate total detected photons
    NphotTot += y[c]
    # normalize correlation
    corrout *= 0
    for b in range(maxx):
        if binfull[b]:
            NphotTotReal = NphotTot
        else:
            NphotTotReal = -1 * intensityBin[b,col[b]] - intensityBin[b, np.mod(col[b]+2, 4)] + NphotTot
        if NphotTotReal > 0:
            corrout[b] = partialcorrelation[b] / NphotTotReal**2 * (np.floor(c / delays[b]) - 2) - 1

plt.figure()
plt.plot(2*delays, corrout)
plt.xscale('log')